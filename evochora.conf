pipeline {
  # Automatically start services in startupSequence when ServiceManager initializes
  # Set to false for manual control via API (useful for development/testing)
  autoStart = true  # default: true

  startupSequence = ["tick-consumer", "simulation-engine"]

  resources {
    #test-queue {
    #  className = "org.evochora.datapipeline.resources.queues.InMemoryBlockingQueue"
    #  options {
    #    capacity = 1000
    #    throughputWindowSeconds = 5
    #  }
    #}

    #consumer-dlq {
    #  className = "org.evochora.datapipeline.resources.queues.InMemoryDeadLetterQueue"
    #  options {
    #    capacity = 100
    #    primaryQueueName = "test-queue"
    #  }
    #}

    #consumer-idempotency-tracker {
    #  className = "org.evochora.datapipeline.resources.idempotency.InMemoryIdempotencyTracker"
    #  options {
    #    ttlSeconds = 3600
    #    cleanupThresholdMessages = 100
    #    cleanupIntervalSeconds = 60
    #  }
    #}

    raw-tick-data-null {
      # TEST: Using NullQueue (/dev/null) to measure pure simulation performance
      className = "org.evochora.datapipeline.resources.queues.NullQueue"
      options {
      }

      # Original configuration (for comparison):
      # className = "org.evochora.datapipeline.resources.queues.InMemoryBlockingQueue"
      # options {
      #   capacity = 10000
      # }
    }

    raw-tick-data {
      className = "org.evochora.datapipeline.resources.queues.InMemoryBlockingQueue"
      options {
        capacity = 10000
        # TEST: Use DirectOutputQueueWrapper to bypass monitoring overhead
        #useDirectWrapper = true
        # TEST: Disable all timestamp tracking inside the queue
        #disableTimestamps = true
      }
    }

    context-data {
      className = "org.evochora.datapipeline.resources.queues.InMemoryBlockingQueue"
      options {
        capacity = 10
      }
    }

    #consumer-dlq {
    #  className = "org.evochora.datapipeline.resources.queues.InMemoryDeadLetterQueue"
    #  options {
    #    capacity = 100
    #    primaryQueueName = "raw-tick-data"
    #  }
    #}

    #consumer-idempotency-tracker {
    #  className = "org.evochora.datapipeline.resources.idempotency.InMemoryIdempotencyTracker"
    #  options {
    #    ttlSeconds = 3600
    #    cleanupThresholdMessages = 100
    #    cleanupIntervalSeconds = 60
    #  }
    #}
  }

  services {
    simulation-engine {
      className = "org.evochora.datapipeline.services.SimulationEngine"
      resources {
        tickData = "queue-out:raw-tick-data-null"
        metadataOutput = "queue-out:context-data"
      }
      options {
        # Sampling interval: capture tick data every N ticks (1 = every tick)
        samplingInterval = 1

        # Time window in seconds for ticks_per_second calculation (default: 1)
        throughputWindowSeconds = 5

        # Optional: Pause simulation at specific ticks for debugging
        pauseTicks = []

        # Random seed for reproducible simulations (omit for random seed)
        seed = 42

        # Environment configuration
        environment {
          # World dimensions (2D: [width, height], 3D: [width, height, depth])
          shape = [100, 100]

          # Topology: "TORUS" for wraparound edges, anything else for bounded
          topology = "TORUS"
        }

        # Energy distribution strategies (multiple can be active simultaneously)
        energyStrategies = [
          {
            className = "org.evochora.runtime.worldgen.GeyserCreator"
            options {
              # Number of geysers to spawn
              count = 5

              # Tick interval between eruptions
              interval = 100

              # Energy amount placed per eruption
              amount = 1000

              # Radius around placement that must be unowned by organisms
              safetyRadius = 2
            }
          },
          {
            className = "org.evochora.runtime.worldgen.SolarRadiationCreator"
            options {
              # Probability per execution to spawn energy (0.0 to 1.0)
              probability = 0.1

              # Energy amount placed when spawn succeeds
              amount = 500

              # Radius around placement that must be unowned by organisms
              safetyRadius = 1

              # Number of independent spawn attempts per tick
              executionsPerTick = 3
            }
          }
        ]

        # Initial organisms to spawn at simulation start
        organisms = [
          {
            # Path to Evochora assembly program file
            program = "assembly/examples/simple.s"

            # Initial energy level
            initialEnergy = 10000

            # Placement in the environment
            placement {
              # Position coordinates [x, y] for 2D or [x, y, z] for 3D
              positions = [50, 50]
            }
          }
        ]

        # Optional: User-defined metadata for experiment tracking
        metadata {
          experiment = "test-run"
          version = "1.0"
        }
      }
    }

    tick-consumer {
      className = "org.evochora.datapipeline.services.DummyConsumerService"
      resources {
        input = "queue-in:raw-tick-data"
        #idempotencyTracker = "tracker:consumer-idempotency-tracker"
        #dlq = "queue-out:consumer-dlq"
      }
      options {
        #processingDelayMs = 50
        maxMessages = -1
      }
    }

    #dummy-consumer {
    #  className = "org.evochora.datapipeline.services.DummyConsumerService"
    #  resources {
    #    input = "queue-in:test-queue"
    #    idempotencyTracker = "tracker:consumer-idempotency-tracker"
    #    dlq = "queue-out:consumer-dlq"
    #  }
    #  options {
    #    # Artificial delay per message in milliseconds (default: 0)
    #    processingDelayMs = 50
    #
    #    # Maximum messages to process, -1 for unlimited (default: -1)
    #    maxMessages = 100
    #
    #    # Time window in seconds for throughput calculation (default: 5)
    #    throughputWindowSeconds = 5
    #
    #    # Maximum processing attempts before sending to DLQ (default: 3)
    #    maxRetries = 3
    #
    #    # Whether to log received messages at DEBUG level (default: false)
    #    #logReceivedMessages = false
    #  }
    #}

    #dummy-producer {
    #  className = "org.evochora.datapipeline.services.DummyProducerService"
    #  resources {
    #    output = "queue-out:test-queue?throughputWindowSeconds=2"
    #  }
    #  options {
    #    # Milliseconds between messages (default: 1000)
    #    intervalMs = 100
    #
    #    # Maximum messages to send, -1 for unlimited (default: -1)
    #    maxMessages = 100
    #
    #    # Time window in seconds for throughput calculation (default: 5)
    #    throughputWindowSeconds = 5
    #
    #    # Prefix for the message content (default: "Message")
    #    #messagePrefix = "Message"
    #  }
    #}
  }
}

logging {
  format = "PLAIN"  # Can be "PLAIN" or "JSON". Defaults to JSON
  default-level = "INFO"  # Default log level for all loggers
  levels {
    # Specific logger levels - override the default for particular components
    "org.evochora.datapipeline.ServiceManager" = "INFO"
  }
}

# The node block configures the server process itself
node {
  # Show ASCII art welcome message on startup (default: false)
  show-welcome-message = true
  
  # Defines all long-running processes the Node should start and manage
  processes {

    # Logical name for the HTTP server process
    http {
      className = "org.evochora.node.processes.http.HttpServerProcess"
      options {
        network {
          host = "0.0.0.0"
          port = 8080

          # Optional: Configure the Jetty thread pool for HTTP request handling
          # Threads are named "<processName>-http-<number>" for easier monitoring
          threadPool {
            minThreads = 8         # Minimum number of threads (default: 8)
            maxThreads = 200       # Maximum number of threads (default: 200)
            idleTimeoutMs = 60000  # Idle timeout in milliseconds (default: 60000)
          }
        }

        # All routes are defined within the HttpServerProcess's options
        routes {
          # The nesting of objects defines the URL paths.
          # Actions ($controller, $static) are defined by keys prefixed with '$'.
          pipeline {
            # ACTION: Serves static UI files at the base path "/pipeline"
            # The static file handler serves from the classpath. A directory named
            # 'web/pipeline-control' should exist in 'src/main/resources'.
            #"$static" = "/web/pipeline-control"

            # Builds the sub-path "/pipeline/api"
            api {
              # ACTION: Serves a controller at "/pipeline/api"
              "$controller" {
                className = "org.evochora.node.processes.http.api.pipeline.PipelineController"
                options {}
              }
            }
          }
        }
      }
    }
  }
}