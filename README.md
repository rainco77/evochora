# Evochora Simulation

Evochora is a digital playground for simulating the evolution of simple, programmable organisms in an n-dimensional environment. It provides a custom assembly language that allows organisms to interact with their environment, reproduce, and compete for resources.

## Project Purpose

The primary goal of this project is to create a flexible and extensible simulation environment for exploring concepts of artificial life and evolution. It allows users to design organisms with custom behaviors and observe how they adapt and evolve over generations.

## Architecture Overview

The simulation is built in Java and consists of several key components:

-   **World**: An n-dimensional grid where organisms live and interact. It contains energy sources and other symbols that organisms can manipulate.
-   **Organism**: An entity with a simple CPU, registers, and a program written in a custom assembly language. Organisms can move, execute instructions, and reproduce.
-   **Assembler**: A multi-pass assembler that translates human-readable assembly code into machine code that organisms can execute. It supports macros, routines, and labels.
-   **Simulation**: The main engine that manages the environment, orchestrates organism actions, and advances the simulation tick by tick.
-   **UI**: A JavaFX-based graphical user interface for visualizing the simulation, inspecting organisms, and controlling the simulation flow.

## How to Build & Test

The project uses Gradle for building and managing dependencies.

-   **Build the project**:
    ```bash
    ./gradlew build
    ```
-   **Run the tests**:
    ```bash
    ./gradlew test
    ```
-   **Run the simulation**:
    ```bash
    ./gradlew run
    ```
-   **Compile assembly files**:
    ```bash
    ./gradlew compile -Pfile="example.s"
    ```

## Documentation

-   **Javadoc**: Detailed documentation for all public APIs can be generated by running `./gradlew javadoc`. The output will be in `build/docs/javadoc/`.
-   **Assembler Specification**: For a complete guide to the assembly language, including syntax, directives, and the full instruction set, please see [ASSEMBLY_SPEC.md](ASSEMBLY_SPEC.md).
-   **Assembly Compile System**: For information on how to compile assembly files and use the system with AI assistants, see [docs/ASSEMBLY_COMPILE_USAGE.md](docs/ASSEMBLY_COMPILE_USAGE.md).

## vNext Highlights & Migration

Whatâ€™s new:
- Stack-based S-variants: ADDS, SUBS, MULS, DIVS, MODS, ANDS, ORS, XORS, NADS, NOTS, SHLS, SHRS.
- Stack ops: DUP, SWAP, DROP, ROT.
- Separate Return-Stack (RS) for CALL/RET + configurable limits (DS_MAX_DEPTH/RS_MAX_DEPTH).
- PROC-local registers (PRs) with automatic save/restore across CALL/RET.
- SCAN/SEEK variants: SCNI (imm vec), SCNS (stack vec), SEKS (stack vec); alias SCNR -> SCAN.
- Includes: signature-deduplicating `.INCLUDE`, forced `.INCLUDE_STRICT`.
- Procs: `.PROC/.ENDP`, `.EXPORT`, `.REQUIRE`, `.IMPORT` with validation.

Migration tips:
- Prefer S-variants to reduce boilerplate PUSH/POP.
- Replace direct register SCAN/SEEK where convenient: use SCNI/SCNS/SEKS; SCNR works as alias for SCAN.
- For reusable code, use `.INCLUDE`; use `.INCLUDE_STRICT` only when a fresh instance is required.
- Declare libraries as `.PROC` with `.EXPORT`; call-sites use `.IMPORT LIB.NAME AS ALIAS`.
- Watch DS/RS depth in programs that recurse or use deep stacks; tune via Config.

Examples: see docs/examples/phase8_examples.s