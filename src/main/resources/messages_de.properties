# German messages
# This file will be populated with keys and German translations.
assembler.exception.formattedMessage=FATALER FEHLER in ''{0}'' (Zeile {1}):\n{2}\n> {3}
assembler.sha256NotFound=SHA-256 nicht gefunden
codeExpander.maxRecursionDepth=Maximale Rekursionstiefe für Makros/Includes erreicht: {0}
codeExpander.infiniteLoopInMacro=Endlosrekursion im Makro erkannt: {0} -> {1}
codeExpander.infiniteLoopInRoutine=Endlosrekursion in Routine erkannt: {0} -> {1}
codeExpander.wrongArgumentCountForMacro=Falsche Argumentanzahl für Makro {0}
codeExpander.invalidIncludeSyntax=Ungültige .INCLUDE Syntax. Erwartet: .INCLUDE <routine> AS <instance> WITH <args...>
codeExpander.invalidIncludeStrictSyntax=Ungültige .INCLUDE_STRICT Syntax. Erwartet: .INCLUDE_STRICT <routine> AS <instance> WITH <args...>
codeExpander.unknownRoutine=Unbekannte Routine: {0}
codeExpander.wrongArgumentCountForRoutine=Falsche Argumentanzahl für Routine {0}. Erwartet {1}, aber {2} erhalten.
definitionExtractor.nestedDefinitionsNotAllowed=Verschachtelte Definitionen sind nicht erlaubt.
definitionExtractor.directiveNeedsName={0} benötigt einen Namen.
definitionExtractor.routineParameterCollidesWithInstruction=Routinen-Parameter ''{0}'' kollidiert mit einem Befehl.
definitionExtractor.unexpectedDirectiveOutsideBlock=Unerwartetes {0} außerhalb eines Definitionsblocks.
definitionExtractor.blockClosedWithWrongEndTag=Block ''{0}'' wurde mit dem falschen End-Tag geschlossen.
definitionExtractor.blockNotClosed=Block ''{0}'' wurde nicht geschlossen.
definitionExtractor.defineArguments=".DEFINE erwartet genau 2 Argumente: NAME WERT."
definitionExtractor.procFormalMustNotBePercent=Formaler Parameter darf nicht mit ''%'' beginnen: {0}
definitionExtractor.pregInvalidSyntax=.PREG erwartet genau zwei Argumente: %NAME INDEX(0|1)
definitionExtractor.pregNameMustStartPercent=.PREG-Name muss mit ''%'' beginnen: {0}
definitionExtractor.pregInvalidIndex=Ung\u00FCltiger .PREG Index: {0}. Nur 0 oder 1 sind erlaubt.
definitionExtractor.pregInvalidContext=.PREG ist nur innerhalb eines .PROC-Blocks erlaubt
passManager.unknownInstruction=Unbekannter Befehl: {0}
passManager.labelRedeclared=Label ''{0}'' wurde mehrfach vergeben.
passManager.labelCollidesWithInstruction=Label ''{0}'' hat denselben Namen wie ein Befehl.
passManager.unexpectedOutputTypeInPass2=Interner Assembler-Fehler: Unerwarteter AssemblerOutput-Typ ({0}) in Phase 2.
passManager.unknownType=Unbekannter Typ: {0}
call.with.requiresWithProc=CALL .WITH setzt eine Ziel-PROC mit formalen Parametern voraus (.PROC NAME WITH ...) (requires).
call.with.usedOnDsProc=CALL .WITH ist f\u00FCr DS-ABI Prozeduren (ohne .PROC WITH) nicht erlaubt.
call.with.arityMismatch=CALL .WITH: Anzahl der Argumente entspricht nicht der Anzahl der formalen Parameter der Ziel-PROC (arity mismatch).
call.with.nonRegisterArg=CALL .WITH erwartet Register-Operanden; ung\u00FCltiges Argument: {0} (non-register)
import.procNotFound=Unbekannter PROC-Alias oder Ziel: {0} (requires .WITH f\u00FCr Register-ABI Prozeduren)
definitionExtractor.autoRetAppended=Warnung: .ENDP hat ein implizites RET f\u00FCr Prozedur ''{0}'' bei {1}:{2} hinzugef\u00FCgt.
call.with.duplicateActuals=Warnung: CALL .WITH nach ''{0}'' bindet doppelte Actuals ({1}); der letzte formale gewinnt.
placeholderResolver.jumpInstructionCoordinateNotFound=Interner Fehler: Koordinate für Sprungbefehl nicht gefunden.
placeholderResolver.unknownLabelForJump=Unbekanntes Label für Sprungbefehl: {0}
placeholderResolver.targetLabelCoordinateNotFound=Interner Fehler: Koordinate für Ziel-Label nicht gefunden: {0}
placeholderResolver.unknownLabelForVector=Unbekanntes Label für Vektor-Zuweisung: {0}
placeholderResolver.vectorInstructionCoordinateNotFound=Interner Fehler: Koordinate für Vektor-Befehl nicht gefunden.
instruction.errorCallingPlanMethod=Fehler beim Aufruf der plan-Methode für {0}
instruction.errorCallingAssembleMethod=Fehler beim Aufruf der assemble-Methode für {0}
instruction.errorRegisteringInstruction=Fehler beim Registrieren der Instruktion: {0}
instruction.idAlreadyRegistered=Instruktions-ID {0} bereits registriert für eine andere Klasse.
instruction.nameAlreadyRegistered=Instruktions-Name ''{0}'' bereits registriert.
appView.restartError.title=Neustart Fehler
appView.restartError.header=Die Simulation konnte nicht neu gestartet werden.
appView.restartError.content=Fehler: {0}
header.button.playPause=Start/Pause
header.button.play=Start
header.button.pause=Pause
header.button.nextTick=Nächster Tick
header.button.restart=Neustart
header.button.loggingOn=Logging: AN
header.button.loggingOff=Logging: AUS
header.button.loggingDisabled=Logging: ---
header.button.zoomNormal=Zoom: Normal
header.button.zoomPixel=Zoom: Pixel
header.label.tick=Tick: {0}
footer.noOrganismSelected=Kein Organismus ausgewählt.\nDRs: ---\nPRs: ---\DS: ---\nRS: ---\nNext: ---\nLine: ---
footer.organismDetails=ID: %d %s | ER: %d | IP: %s | DP: %s | DV: %s\n
footer.organismStatus.dead=(TOT)
footer.label.drs=DRs:
footer.label.prs=PRs:
footer.label.stack=DS:
footer.label.rs=RS:
footer.label.nextInstruction=Nächste:
footer.label.line=Zeile:
footer.notAvailable=N/V