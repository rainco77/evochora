package org.evochora.compiler.e2e;

import org.evochora.compiler.Compiler;
import org.evochora.compiler.api.ProgramArtifact;
import org.evochora.runtime.Config;
import org.evochora.runtime.Simulation;
import org.evochora.runtime.internal.services.CallBindingRegistry;
import org.evochora.runtime.model.Environment;
import org.evochora.runtime.model.Molecule;
import org.evochora.runtime.model.Organism;
import org.evochora.runtime.isa.Instruction;
import org.evochora.runtime.model.EnvironmentProperties;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Contains integration tests that verify the interaction between the compiler and the runtime simulation.
 * These tests compile source code, load the resulting artifact into a simulated environment,
 * execute the code, and then assert that the runtime behavior is correct.
 * These are tagged as "integration" tests because they span the compiler and runtime subsystems.
 */
public class RuntimeIntegrationTest {

	@BeforeAll
	static void setUp() {
		Instruction.init();
	}

	/**
	 * Compiles a procedure with parameters, loads it into a simulation, and runs it.
	 * This test verifies that the compiled code can be executed by an organism in the runtime environment.
	 * This is an integration test.
	 *
	 * @throws Exception if compilation or simulation fails.
	 */
	@Test
    @Tag("integration")
	void procedureWithParametersAddsValuesAtRuntime() throws Exception {
		String source = String.join("\n",
				".PROC ADD2 EXPORT WITH A B",
				"  ADDR A B",
				"  RET",
				".ENDP",
				"SETI %DR0 DATA:1",
				"SETI %DR1 DATA:2",
				"CALL ADD2 WITH %DR0 %DR1",
				"NOP"
		);

		Compiler compiler = new Compiler();
		EnvironmentProperties envProps = new EnvironmentProperties(new int[]{64, 64}, true);
		ProgramArtifact artifact = compiler.compile(Arrays.asList(source.split("\\r?\\n")), "rt_proc_params.s", envProps);
		assertThat(artifact).isNotNull();

		// Create a small environment and simulation
		Environment env = new Environment(envProps);
		Simulation sim = new Simulation(env);

		// Place program at origin (0,0)
		for (Map.Entry<int[], Integer> e : artifact.machineCodeLayout().entrySet()) {
			int[] rel = e.getKey();
			int[] abs = new int[]{rel[0], rel[1]};
			env.setMolecule(Molecule.fromInt(e.getValue()), abs);
		}

		Organism org = Organism.create(sim, new int[]{0, 0}, 1000, sim.getLogger());
		org.setProgramId(artifact.programId());
		sim.addOrganism(org);

		// Run a few ticks to execute SETI, SETI, CALL, and within proc ADDR and RET
		for (int i = 0; i < 10; i++) sim.tick();

		// Basic runtime sanity checks
		assertThat(org.getDrs().size()).isGreaterThan(1);
		assertThat(org.getDrs().get(0)).isNotNull();
		assertThat(org.getDrs().get(1)).isNotNull();
	}

    /**
     * Verifies that the compiled machine code for procedure calls is self-sufficient
     * and does not depend on the {@link ProgramArtifact} being available at runtime.
     * It compiles a program, loads the machine code, but withholds the artifact from the simulation.
     * The test passes if the procedure's side effect (modifying a register) is still correct,
     * proving that the PUSH/POP instructions generated by the compiler are solely responsible
     * for parameter passing.
	 * This is an integration test.
     *
     * @throws Exception if compilation or simulation fails.
     */
    @Test
    @Tag("integration")
    void procedureCopyOut_worksWithoutProgramArtifact() throws Exception {
        String source = String.join("\n",
                ".PROC INCREMENT EXPORT WITH VALUE",
                "  ADDI VALUE DATA:1",
                "  RET",
                ".ENDP",
                "SETI %DR0 DATA:41",
                "CALL INCREMENT WITH %DR0",
                "NOP"
        );

        Compiler compiler = new Compiler();
        EnvironmentProperties envProps = new EnvironmentProperties(new int[]{64, 64}, true);
        ProgramArtifact artifact = compiler.compile(Arrays.asList(source.split("\\r?\\n")), "artifact_free_test.s", envProps);
        assertThat(artifact).isNotNull();

        Environment env = new Environment(envProps);
        Simulation sim = new Simulation(env);
        sim.setProgramArtifacts(Collections.emptyMap());

        for (Map.Entry<int[], Integer> e : artifact.machineCodeLayout().entrySet()) {
            env.setMolecule(Molecule.fromInt(e.getValue()), e.getKey());
        }

        Organism org = Organism.create(sim, new int[]{0, 0}, 1000, sim.getLogger());
        org.setProgramId(artifact.programId());
        sim.addOrganism(org);

        for (int i = 0; i < 15; i++) {
            sim.tick();
        }

        Molecule result = Molecule.fromInt((Integer) org.getDr(0));
        assertThat(result.toScalarValue())
                .as("Der Wert sollte nach dem Prozeduraufruf auf 42 inkrementiert sein, auch ohne Artefakt.")
                .isEqualTo(42);
        assertThat(org.isInstructionFailed()).isFalse();
    }

    @Test
    @Tag("integration")
    void procedureCall_worksCorrectlyWithCorruptedProgramArtifact() throws Exception {
        String sourceCode = String.join("\n",
                ".PROC ADD EXPORT WITH A B",
                "  ADDR A B",
                "  RET",
                ".ENDP",
                "SETI %DR0 DATA:10",
                "SETI %DR1 DATA:20",
                "CALL ADD WITH %DR0 %DR1",
                "NOP"
        );

        Compiler compiler = new Compiler();
        EnvironmentProperties envProps = new EnvironmentProperties(new int[]{64, 64}, true);
        ProgramArtifact correctArtifact = compiler.compile(Arrays.asList(sourceCode.split("\\r?\\n")), "correct.s", envProps);
        assertThat(correctArtifact).isNotNull();

        Map<Integer, int[]> corruptedBindings = new HashMap<>();
        correctArtifact.callSiteBindings().forEach((addr, bindings) -> {
            corruptedBindings.put(addr, new int[]{1});
        });

        ProgramArtifact corruptedArtifact = new ProgramArtifact(
                correctArtifact.programId(),
                correctArtifact.sources(),
                correctArtifact.machineCodeLayout(),
                correctArtifact.initialWorldObjects(),
                correctArtifact.sourceMap(),
                corruptedBindings,
                correctArtifact.relativeCoordToLinearAddress(),
                correctArtifact.linearAddressToCoord(),
                correctArtifact.labelAddressToName(),
                correctArtifact.registerAliasMap(),
                correctArtifact.procNameToParamNames(),
                correctArtifact.tokenMap(),
                correctArtifact.tokenLookup()
        );

        Environment env = new Environment(envProps);
        Simulation sim = new Simulation(env);

        for (Map.Entry<int[], Integer> e : correctArtifact.machineCodeLayout().entrySet()) {
            env.setMolecule(Molecule.fromInt(e.getValue()), e.getKey());
        }

        sim.setProgramArtifacts(Map.of(corruptedArtifact.programId(), corruptedArtifact));

        Organism org = Organism.create(sim, new int[]{0, 0}, 1000, sim.getLogger());
        org.setProgramId(correctArtifact.programId());
        sim.addOrganism(org);

        CallBindingRegistry.getInstance().clearAll();
        for (var binding : corruptedArtifact.callSiteBindings().entrySet()) {
            int[] coord = corruptedArtifact.linearAddressToCoord().get(binding.getKey());
            if (coord != null) {
                CallBindingRegistry.getInstance().registerBindingForAbsoluteCoord(coord, binding.getValue());
            }
        }

        for (int i = 0; i < 20; i++) {
            sim.tick();
        }

        Molecule result = Molecule.fromInt((Integer) org.getDr(0));
        assertThat(result.toScalarValue())
                .as("Das Ergebnis der Addition muss 30 sein, basierend auf dem Maschinencode, nicht dem falschen Artefakt.")
                .isEqualTo(30);
        assertThat(org.isInstructionFailed()).isFalse();
    }
}
